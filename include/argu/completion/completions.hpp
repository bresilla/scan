#pragma once

/// @file argu/completion/completions.hpp
/// @brief Shell completion script generation implementations

#include <argu/completion/generator.hpp>
#include <argu/core/command.hpp>

#include <sstream>

namespace argu {

    inline std::string CompletionGenerator::generate_bash() const {
        std::ostringstream oss;
        const std::string &name = m_cmd.name();

        oss << "# Bash completion script for " << name << "\n";
        oss << "# Generated by argu\n\n";

        oss << "_" << name << "_completions() {\n";
        oss << "    local cur prev opts\n";
        oss << "    COMPREPLY=()\n";
        oss << "    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n";
        oss << "    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n\n";

        // Options
        oss << "    opts=\"";
        for (const auto &arg : m_cmd.get_args()) {
            if (arg.is_hidden())
                continue;
            if (arg.short_opt()) {
                oss << "-" << *arg.short_opt() << " ";
            }
            if (arg.long_opt()) {
                oss << "--" << *arg.long_opt() << " ";
            }
        }
        oss << "\"\n\n";

        // Subcommands
        if (!m_cmd.get_subcommands().empty()) {
            oss << "    subcommands=\"";
            for (const auto &sub : m_cmd.get_subcommands()) {
                if (!sub->is_hidden()) {
                    oss << sub->name() << " ";
                }
            }
            oss << "\"\n\n";
        }

        // Handle value completion for specific options
        oss << "    case \"${prev}\" in\n";
        for (const auto &arg : m_cmd.get_args()) {
            if (arg.is_hidden() || arg.is_flag() || arg.is_count())
                continue;

            std::string opt_case;
            if (arg.short_opt())
                opt_case += "-" + std::string(1, *arg.short_opt());
            if (arg.long_opt()) {
                if (!opt_case.empty())
                    opt_case += "|";
                opt_case += "--" + *arg.long_opt();
            }

            if (!opt_case.empty()) {
                oss << "        " << opt_case << ")\n";

                // If has choices, complete from choices
                if (!arg.get_choices().empty()) {
                    oss << "            COMPREPLY=( $(compgen -W \"";
                    for (const auto &c : arg.get_choices()) {
                        oss << escape_bash(c) << " ";
                    }
                    oss << "\" -- \"${cur}\") )\n";
                    oss << "            return 0\n";
                } else {
                    // Check value hint first, then fall back to value name
                    std::string hint = arg.get_value_hint().value_or(arg.value_name_str());
                    if (hint == "FILE" || hint == "PATH") {
                        oss << "            COMPREPLY=( $(compgen -f -- \"${cur}\") )\n";
                        oss << "            return 0\n";
                    } else if (hint == "DIR" || hint == "DIRECTORY") {
                        oss << "            COMPREPLY=( $(compgen -d -- \"${cur}\") )\n";
                        oss << "            return 0\n";
                    } else if (hint == "HOST" || hint == "HOSTNAME") {
                        oss << "            COMPREPLY=( $(compgen -A hostname -- \"${cur}\") )\n";
                        oss << "            return 0\n";
                    } else if (hint == "USER" || hint == "USERNAME") {
                        oss << "            COMPREPLY=( $(compgen -A user -- \"${cur}\") )\n";
                        oss << "            return 0\n";
                    } else if (hint == "CMD" || hint == "COMMAND") {
                        oss << "            COMPREPLY=( $(compgen -c -- \"${cur}\") )\n";
                        oss << "            return 0\n";
                    }
                }
                oss << "            ;;\n";
            }
        }
        oss << "    esac\n\n";

        // Default completion
        oss << "    if [[ ${cur} == -* ]]; then\n";
        oss << "        COMPREPLY=( $(compgen -W \"${opts}\" -- \"${cur}\") )\n";
        if (!m_cmd.get_subcommands().empty()) {
            oss << "    elif [[ ${COMP_CWORD} -eq 1 ]]; then\n";
            oss << "        COMPREPLY=( $(compgen -W \"${subcommands} ${opts}\" -- \"${cur}\") )\n";
        }
        oss << "    else\n";
        oss << "        COMPREPLY=( $(compgen -f -- \"${cur}\") )\n";
        oss << "    fi\n";
        oss << "}\n\n";

        oss << "complete -F _" << name << "_completions " << name << "\n";

        return oss.str();
    }

    inline std::string CompletionGenerator::generate_zsh() const {
        std::ostringstream oss;
        const std::string &name = m_cmd.name();

        oss << "#compdef " << name << "\n\n";
        oss << "# Zsh completion script for " << name << "\n";
        oss << "# Generated by argu\n\n";

        oss << "_" << name << "() {\n";
        oss << "    local -a opts subcommands\n\n";

        // Options
        oss << "    opts=(\n";
        for (const auto &arg : m_cmd.get_args()) {
            if (arg.is_hidden())
                continue;

            std::string desc = arg.help_text();
            // Escape special characters in description
            for (char &c : desc) {
                if (c == '\'' || c == '"' || c == ':')
                    c = ' ';
            }

            if (arg.short_opt() && arg.long_opt()) {
                oss << "        '(-" << *arg.short_opt() << " --" << *arg.long_opt() << ")'{-" << *arg.short_opt()
                    << ",--" << *arg.long_opt() << "}'[" << desc << "]";
            } else if (arg.long_opt()) {
                oss << "        '--" << *arg.long_opt() << "[" << desc << "]";
            } else if (arg.short_opt()) {
                oss << "        '-" << *arg.short_opt() << "[" << desc << "]";
            } else {
                continue;
            }

            // Add value completion hints
            if (!arg.is_flag() && !arg.is_count()) {
                if (!arg.get_choices().empty()) {
                    oss << ":choice:(";
                    for (const auto &c : arg.get_choices()) {
                        oss << c << " ";
                    }
                    oss << ")";
                } else {
                    // Check value hint first, then fall back to value name
                    std::string hint = arg.get_value_hint().value_or(arg.value_name_str());
                    if (hint == "FILE" || hint == "PATH") {
                        oss << ":file:_files";
                    } else if (hint == "DIR" || hint == "DIRECTORY") {
                        oss << ":dir:_directories";
                    } else if (hint == "HOST" || hint == "HOSTNAME") {
                        oss << ":host:_hosts";
                    } else if (hint == "USER" || hint == "USERNAME") {
                        oss << ":user:_users";
                    } else if (hint == "CMD" || hint == "COMMAND") {
                        oss << ":command:_command_names";
                    } else if (hint == "URL") {
                        oss << ":url:_urls";
                    } else if (hint == "EMAIL") {
                        oss << ":email:_email_addresses";
                    } else {
                        oss << ":" << hint << ":";
                    }
                }
            }
            oss << "'\n";
        }
        oss << "    )\n\n";

        // Subcommands
        if (!m_cmd.get_subcommands().empty()) {
            oss << "    subcommands=(\n";
            for (const auto &sub : m_cmd.get_subcommands()) {
                if (!sub->is_hidden()) {
                    std::string desc = sub->get_about() ? *sub->get_about() : "";
                    for (char &c : desc)
                        if (c == '\'' || c == ':')
                            c = ' ';
                    oss << "        '" << sub->name() << ":" << desc << "'\n";
                }
            }
            oss << "    )\n\n";

            oss << "    _arguments -C $opts \\\n";
            oss << "        '1:command:->cmds' \\\n";
            oss << "        '*::arg:->args'\n\n";

            oss << "    case \"$state\" in\n";
            oss << "        cmds)\n";
            oss << "            _describe -t commands 'commands' subcommands\n";
            oss << "            ;;\n";
            oss << "        args)\n";
            oss << "            case \"${words[1]}\" in\n";
            for (const auto &sub : m_cmd.get_subcommands()) {
                if (!sub->is_hidden()) {
                    oss << "                " << sub->name() << ")\n";
                    oss << "                    _" << name << "_" << sub->name() << "\n";
                    oss << "                    ;;\n";
                }
            }
            oss << "            esac\n";
            oss << "            ;;\n";
            oss << "    esac\n";
        } else {
            oss << "    _arguments $opts\n";
        }

        oss << "}\n\n";

        // Generate subcommand completions
        for (const auto &sub : m_cmd.get_subcommands()) {
            if (!sub->is_hidden()) {
                CompletionGenerator sub_gen(*sub);
                oss << "_" << name << "_" << sub->name() << "() {\n";
                oss << "    local -a opts\n";
                oss << "    opts=(\n";
                for (const auto &arg : sub->get_args()) {
                    if (arg.is_hidden())
                        continue;
                    if (arg.long_opt()) {
                        std::string desc = arg.help_text();
                        for (char &c : desc)
                            if (c == '\'' || c == ':')
                                c = ' ';
                        oss << "        '--" << *arg.long_opt() << "[" << desc << "]'\n";
                    }
                }
                oss << "    )\n";
                oss << "    _arguments $opts\n";
                oss << "}\n\n";
            }
        }

        oss << "_" << name << " \"$@\"\n";

        return oss.str();
    }

    inline std::string CompletionGenerator::generate_fish() const {
        std::ostringstream oss;
        const std::string &name = m_cmd.name();

        oss << "# Fish completion script for " << name << "\n";
        oss << "# Generated by argu\n\n";

        // Disable file completion by default
        oss << "complete -c " << name << " -f\n\n";

        // Add options
        for (const auto &arg : m_cmd.get_args()) {
            if (arg.is_hidden())
                continue;

            oss << "complete -c " << name;

            if (arg.short_opt()) {
                oss << " -s " << *arg.short_opt();
            }
            if (arg.long_opt()) {
                oss << " -l " << *arg.long_opt();
            }

            if (!arg.help_text().empty()) {
                oss << " -d '" << escape_fish(arg.help_text()) << "'";
            }

            // Add value requirements
            if (!arg.is_flag() && !arg.is_count()) {
                oss << " -r";

                if (!arg.get_choices().empty()) {
                    oss << " -a '";
                    for (std::size_t i = 0; i < arg.get_choices().size(); ++i) {
                        if (i > 0)
                            oss << " ";
                        oss << escape_fish(arg.get_choices()[i]);
                    }
                    oss << "'";
                } else {
                    // Check value hint first, then fall back to value name
                    std::string hint = arg.get_value_hint().value_or(arg.value_name_str());
                    if (hint == "FILE" || hint == "PATH") {
                        oss << " -F"; // Enable file completion
                    } else if (hint == "DIR" || hint == "DIRECTORY") {
                        oss << " -a '(__fish_complete_directories)'";
                    } else if (hint == "HOST" || hint == "HOSTNAME") {
                        oss << " -a '(__fish_print_hostnames)'";
                    } else if (hint == "USER" || hint == "USERNAME") {
                        oss << " -a '(__fish_complete_users)'";
                    } else if (hint == "CMD" || hint == "COMMAND") {
                        oss << " -a '(__fish_complete_command)'";
                    }
                }
            }

            oss << "\n";
        }

        // Add subcommands
        for (const auto &sub : m_cmd.get_subcommands()) {
            if (!sub->is_hidden()) {
                oss << "complete -c " << name << " -n '__fish_use_subcommand' -a '" << sub->name() << "'";
                if (sub->get_about()) {
                    oss << " -d '" << escape_fish(*sub->get_about()) << "'";
                }
                oss << "\n";
            }
        }

        return oss.str();
    }

    inline std::string CompletionGenerator::generate_powershell() const {
        std::ostringstream oss;
        const std::string &name = m_cmd.name();

        oss << "# PowerShell completion script for " << name << "\n";
        oss << "# Generated by argu\n\n";

        oss << "Register-ArgumentCompleter -Native -CommandName " << name << " -ScriptBlock {\n";
        oss << "    param($wordToComplete, $commandAst, $cursorPosition)\n\n";

        oss << "    $completions = @(\n";

        // Options
        for (const auto &arg : m_cmd.get_args()) {
            if (arg.is_hidden())
                continue;

            if (arg.long_opt()) {
                oss << "        [CompletionResult]::new('--" << *arg.long_opt() << "', '--" << *arg.long_opt()
                    << "', 'ParameterName', '" << arg.help_text() << "')\n";
            }
            if (arg.short_opt()) {
                oss << "        [CompletionResult]::new('-" << *arg.short_opt() << "', '-" << *arg.short_opt()
                    << "', 'ParameterName', '" << arg.help_text() << "')\n";
            }
        }

        // Subcommands
        for (const auto &sub : m_cmd.get_subcommands()) {
            if (!sub->is_hidden()) {
                std::string desc = sub->get_about() ? *sub->get_about() : "";
                oss << "        [CompletionResult]::new('" << sub->name() << "', '" << sub->name() << "', 'Command', '"
                    << desc << "')\n";
            }
        }

        oss << "    )\n\n";

        oss << "    $completions | Where-Object { $_.CompletionText -like \"$wordToComplete*\" }\n";
        oss << "}\n";

        return oss.str();
    }

    inline std::string CompletionGenerator::generate_elvish() const {
        std::ostringstream oss;
        const std::string &name = m_cmd.name();

        oss << "# Elvish completion script for " << name << "\n";
        oss << "# Generated by argu\n\n";

        oss << "edit:completion:arg-completer[" << name << "] = {|@args|\n";
        oss << "    var completions = [\n";

        // Options
        for (const auto &arg : m_cmd.get_args()) {
            if (arg.is_hidden())
                continue;

            if (arg.long_opt()) {
                oss << "        &[stem='--" << *arg.long_opt() << "' display='--" << *arg.long_opt() << " ("
                    << arg.help_text() << ")']\n";
            }
        }

        // Subcommands
        for (const auto &sub : m_cmd.get_subcommands()) {
            if (!sub->is_hidden()) {
                std::string desc = sub->get_about() ? *sub->get_about() : "";
                oss << "        &[stem='" << sub->name() << "' display='" << sub->name() << " (" << desc << ")']\n";
            }
        }

        oss << "    ]\n";
        oss << "    put $@completions\n";
        oss << "}\n";

        return oss.str();
    }

    // Implementation of Command::generate_completions
    inline std::string Command::generate_completions(Shell shell) const {
        CompletionGenerator gen(*this);
        return gen.generate(shell);
    }

} // namespace argu
